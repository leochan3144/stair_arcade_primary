<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Stair Game - Primary Math</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.4/TweenMax.min.js"></script>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background-color: black;
      font-family: Arial, sans-serif;
      touch-action: none;
    }

    canvas {
      display: block;
      max-width: 100%;
      height: auto;
    }

    #startBtn {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      padding: 15px 40px;
      width: 80%;
      max-width: 300px;
      background-color: rgba(255, 255, 255, 0.2);
      color: white;
      border-radius: 500px;
      outline: none;
      font-size: 30px;
      letter-spacing: 1px;
      cursor: pointer;
      border: none;
      box-shadow: 0px 0px 20px rgba(255, 255, 255, 0.3);
      z-index: 10;
      white-space: nowrap;
    }

    #startBtn:hover {
      background-color: rgba(255, 255, 255, 0.3);
    }
    
    /* Leaderboard styles */
    #leaderboard {
      display: none; 
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.95);
      color: white;
      padding: 20px;
      border-radius: 15px;
      font-size: 16px;
      z-index: 25;
      width: 85%;
      max-width: 350px;
      box-shadow: 0 0 20px rgba(83, 211, 55, 0.5);
      border: 2px solid #53d337;
      max-height: 80vh;
      overflow-y: auto;
      box-sizing: border-box;
    }
    
    #leaderboard h3 {
      margin: 0 0 15px 0;
      text-align: center;
      color: #ffdd38;
      font-size: 22px;
    }
    
    #leaderboard ol {
      padding-left: 25px;
      margin: 0;
    }
    
    #leaderboard li {
      margin-bottom: 6px;
      color: white;
      font-size: 16px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      padding: 4px 0;
    }
    
    .current-score {
      color: #53d337 !important;
      font-weight: bold;
    }

    #restartBtn {
        display: block;
        margin: 20px auto 0 auto;
        padding: 10px 30px;
        width: 100%;
        background-color: #53d337;
        color: white;
        border: none;
        border-radius: 5px;
        font-size: 18px;
        cursor: pointer;
    }
    
    /* Name input modal */
    #nameModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.85);
      z-index: 30;
      justify-content: center;
      align-items: center;
    }
    
    .modal-content {
      background-color: rgba(50, 50, 50, 0.95);
      padding: 30px;
      width: 80%;
      max-width: 300px;
      border-radius: 15px;
      text-align: center;
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
    }
    
    #nameInput {
      padding: 10px;
      font-size: 18px;
      border: 2px solid #53d337;
      border-radius: 5px;
      background-color: #222;
      color: white;
      margin: 15px 0;
      width: 80%;
      text-align: center;
    }
    
    #submitName {
      padding: 10px 30px;
      font-size: 18px;
      background-color: #53d337;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 10px;
      width: 100%;
    }
    
    .modal-title {
      color: #ffdd38;
      font-size: 24px;
      margin-bottom: 15px;
    }
    
    /* Touch controls */
    #touchControls {
      position: fixed;
      top: 50%; 
      transform: translateY(-50%);
      width: 100%;
      display: flex;
      justify-content: space-between; 
      padding: 0 20px;
      box-sizing: border-box;
      z-index: 20;
      pointer-events: none; 
    }
    
    .touch-btn {
      pointer-events: auto; 
      width: 80px;
      height: 80px;
      background-color: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 30px;
      color: white;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      transition: background-color 0.1s;
      backdrop-filter: blur(2px);
    }

    .touch-btn:active {
        background-color: rgba(255, 255, 255, 0.4);
    }
  </style>
</head>
<body>
  <canvas id="mycanvas"></canvas>
  <button id="startBtn" onclick="game.start()">Start Math</button>

  <div id="leaderboard">
    <h3>üèÜ Math Ranking</h3>
    <ol id="scoresList"></ol>
    <button id="restartBtn" onclick="game.restartGame()">Play again</button>
  </div>

  <div id="nameModal">
    <div class="modal-content">
      <div class="modal-title">New RecordÔºÅ</div>
      <div class="score-display">Basement <span id="currentScoreDisplay" style="color:#53d337; font-weight:bold;">0</span> /F</div>
      <input type="text" id="nameInput" placeholder="Input your name" maxlength="8" autocomplete="off">
      <br>
      <button id="submitName">Submit</button>
    </div>
  </div>
  
  <div id="touchControls">
    <div class="touch-btn" id="leftBtn">‚óÄ</div>
    <div class="touch-btn" id="rightBtn">‚ñ∂</div>
  </div>

  <audio id="musicBg" src="sound/bgm.mp3" preload="auto"></audio>
  <audio id="transmiting" src="sound/step.mp3" preload="auto"></audio>
  <audio id="hurt" src="sound/hurt.mp3" preload="auto"></audio>
  <audio id="fade" src="sound/fade.mp3" preload="auto"></audio>
  <audio id="dead" src="sound/help.mp3" preload="auto"></audio>
  <audio id="step" src="sound/step.mp3" preload="auto"></audio>
  <audio id="jump" src="sound/jump.mp3" preload="auto"></audio>
  <audio id="correct" src="https://actions.google.com/sounds/v1/cartoon/pop.ogg" preload="auto"></audio> 
  
  <script>
    // Global Vars
    var updateFPS = 30
    var time = 0
    var bgColor ="black"
    var ww, wh; 

    // Controls
    var controls = {
      value: 0
    }
    var gui = new dat.GUI()
    gui.add(controls,"value",-2,2).step(0.01).onChange(function(value){})
    gui.close(); 
    document.querySelector('.dg.ac').style.display = 'none';

    var bgm = document.getElementById('musicBg');
    bgm.volume = 0.4;
    document.getElementById('transmiting').volume=0.3
    document.getElementById('step').volume=0.7
    bgm.addEventListener('ended', function(){
      this.currentTime = 0;
      this.play();
    }, false);

    //------------------------
    // Graphics Helpers
    //------------------------
    
    // 1. Draw Single Expression (Used for Walls)
    // Supports "1_over_2" syntax for fractions
    const drawFormalExpression = (ctx, text, x, y, fontSize, color = "white", align = "center") => {
        ctx.fillStyle = color;
        
        if (text && text.includes("_over_")) {
            const parts = text.split("_over_");
            const num = parts[0];
            const den = parts[1];
            
            ctx.font = "bold " + (fontSize * 0.85) + "px Arial";
            const numMetrics = ctx.measureText(num);
            const denMetrics = ctx.measureText(den);
            const maxWidth = Math.max(numMetrics.width, denMetrics.width);
            
            let startX = x;
            if (align === "center") startX = x - maxWidth / 2;
            else if (align === "right") startX = x - maxWidth;

            ctx.textAlign = "center";
            ctx.fillText(num, startX + maxWidth / 2, y - fontSize * 0.4);
            
            ctx.fillRect(startX, y - fontSize * 0.25, maxWidth, Math.max(2, fontSize/15));
            
            ctx.fillText(den, startX + maxWidth / 2, y + fontSize * 0.7);
            ctx.textAlign = align;
        } else {
            ctx.font = "bold " + fontSize + "px Arial";
            ctx.textAlign = align;
            ctx.fillText(text, x, y);
        }
    };

    // 2. Draw Complex Equation (Used for Top Question)
    // Accepts array of parts: [{type:'text', val:'...'}, {type:'frac', num:'1', den:'2'}]
    const drawEquation = (ctx, parts, x, y, fontSize, color = "white") => {
        ctx.fillStyle = color;
        ctx.textAlign = "left"; // Internal calculation uses left alignment
        
        // 1. Calculate Total Width
        let totalWidth = 0;
        parts.forEach(part => {
            if (part.type === 'text') {
                ctx.font = "bold " + fontSize + "px Arial";
                totalWidth += ctx.measureText(part.val).width;
            } else if (part.type === 'frac') {
                ctx.font = "bold " + (fontSize * 0.85) + "px Arial";
                let nw = ctx.measureText(part.num).width;
                let dw = ctx.measureText(part.den).width;
                part.width = Math.max(nw, dw) + 4; // +4 padding
                totalWidth += part.width + 8; // +8 spacing
            }
        });

        // 2. Draw Center Aligned
        let currentX = x - totalWidth / 2;
        
        parts.forEach(part => {
            if (part.type === 'text') {
                ctx.font = "bold " + fontSize + "px Arial";
                ctx.fillText(part.val, currentX, y);
                currentX += ctx.measureText(part.val).width;
            } else if (part.type === 'frac') {
                ctx.font = "bold " + (fontSize * 0.85) + "px Arial";
                let mx = currentX + part.width / 2 + 4; 
                
                ctx.textAlign = "center";
                ctx.fillText(part.num, mx, y - fontSize * 0.35);
                
                ctx.fillRect(mx - part.width/2 + 2, y - fontSize * 0.25, part.width - 4, Math.max(2, fontSize/15));
                
                ctx.fillText(part.den, mx, y + fontSize * 0.75);
                
                ctx.textAlign = "left"; 
                currentX += part.width + 8;
            }
        });
        ctx.textAlign = "center"; // Reset
    };

    //------------------------
    // Vector Class
    class Vec2{
      constructor(x,y){
        this.x = x; this.y = y;
      }
      set(x,y){
        this.x =x; this.y =y;
      }
      add(v){
        return new Vec2(this.x+v.x,this.y+v.y)
      }
      mul(s){
        return new Vec2(this.x*s,this.y*s)
      }
      clone(){
        return new Vec2(this.x,this.y)
      }
    }

    var canvas = document.getElementById("mycanvas")
    var ctx = canvas.getContext("2d")

    function playSound(id){
      var sound = document.getElementById(id);
      sound.currentTime=0
      sound.play().catch(e => console.log(e)); 
    }

    function getLeaderboard() {
      const saved = localStorage.getItem('stairGameLeaderboard_primary'); 
      return saved ? JSON.parse(saved) : [];
    }

    function saveLeaderboard(scores) {
      localStorage.setItem('stairGameLeaderboard_primary', JSON.stringify(scores));
    }

    function updateLeaderboardDisplay() {
      const scores = getLeaderboard();
      const scoresList = document.getElementById('scoresList');
      scoresList.innerHTML = '';
      scores.slice(0, 10).forEach((entry) => {
        const li = document.createElement('li');
        li.textContent = `${entry.name}: ${entry.score}/F`;
        if (entry.isCurrent) li.classList.add('current-score');
        scoresList.appendChild(li);
      });
    }

    function checkNewRecord(score) {
      const scores = getLeaderboard();
      if (scores.length >= 10 && score <= scores[9].score) {
        document.getElementById('leaderboard').style.display = 'block';
        updateLeaderboardDisplay();
        return;
      }
      document.getElementById('currentScoreDisplay').textContent = score;
      document.getElementById('nameModal').style.display = 'flex';
      setTimeout(()=> document.getElementById('nameInput').focus(), 100);
    }

    function submitName() {
      const name = document.getElementById('nameInput').value.trim() || 'Unknown';
      const score = parseInt(document.getElementById('currentScoreDisplay').textContent);
      const scores = getLeaderboard();
      scores.forEach(s => s.isCurrent = false);
      scores.push({ score: score, name: name, isCurrent: true });
      scores.sort((a, b) => b.score - a.score); 
      saveLeaderboard(scores.slice(0, 10));
      document.getElementById('nameModal').style.display = 'none';
      document.getElementById('leaderboard').style.display = 'block';
      updateLeaderboardDisplay();
    }

    //------------------------
    // GAME CLASS
    //------------------------
    class Game{
      constructor(){
        this.player = null
        this.walls = []
        this.width = Math.min(window.innerWidth, 700) 
        this.height = wh
        this.walltypes = ["normal","jump","slideLeft","slideRight","hurt","fade"]
        this.hurt=0
        this.playing=false
        this.keystatus = { left: false, right: false }
        this.time=0
        
        // Question Data
        this.questionParts = []; // Array for render
        this.correctAnswer = "";
        this.wrongAnswer = "";
      }
      
      gcd(a, b) {
        return b == 0 ? a : this.gcd(b, a % b);
      }

      formatFraction(num, den) {
        if (den === 0) return "Error";
        let common = this.gcd(Math.abs(num), Math.abs(den));
        num /= common;
        den /= common;
        if (den === 1) return num.toString();
        return `${num}_over_${den}`;
      }

      generateMathProblem() {
        const typeRoll = Math.random();
        this.questionParts = [];

        // Type 1: Mixed Operations (Integers)
        if (typeRoll < 0.4) {
            let n1 = Math.floor(Math.random() * 9) + 2;
            let n2 = Math.floor(Math.random() * 9) + 2;
            let n3 = Math.floor(Math.random() * 5) + 2;
            
            if (Math.random() < 0.5) {
                // 2 + 3 x 4
                this.questionParts.push({type:'text', val: `${n1} + ${n2} √ó ${n3} = ?`});
                this.correctAnswer = (n1 + (n2 * n3)).toString();
                this.wrongAnswer = ((n1 + n2) * n3).toString();
            } else {
                // (2 + 3) x 4
                this.questionParts.push({type:'text', val: `(${n1} + ${n2}) √ó ${n3} = ?`});
                this.correctAnswer = ((n1 + n2) * n3).toString();
                this.wrongAnswer = (n1 + (n2 * n3)).toString();
            }
        } 
        // Type 2: Fraction Addition
        else if (typeRoll < 0.7) {
            let den = Math.floor(Math.random() * 8) + 2; 
            let n1 = Math.floor(Math.random() * (den - 1)) + 1; 
            let n2 = Math.floor(Math.random() * (den - 1)) + 1;
            
            // Render: n1/den + n2/den = ?
            this.questionParts.push({type:'frac', num:n1.toString(), den:den.toString()});
            this.questionParts.push({type:'text', val: " + "});
            this.questionParts.push({type:'frac', num:n2.toString(), den:den.toString()});
            this.questionParts.push({type:'text', val: " = ?"});
            
            this.correctAnswer = this.formatFraction(n1 + n2, den);
            this.wrongAnswer = this.formatFraction(n1 + n2, den * 2); 
            if (this.wrongAnswer === this.correctAnswer) this.wrongAnswer = this.formatFraction(n1 + n2 + 1, den);
        }
        // Type 3: Integer * Fraction
        else {
            let den = Math.floor(Math.random() * 5) + 3; 
            let mult = Math.floor(Math.random() * 4) + 2;
            
            // Render: mult x 1/den = ?
            this.questionParts.push({type:'text', val: `${mult} √ó `});
            this.questionParts.push({type:'frac', num:"1", den:den.toString()});
            this.questionParts.push({type:'text', val: " = ?"});
            
            this.correctAnswer = this.formatFraction(mult, den);
            this.wrongAnswer = this.formatFraction(1, den * mult);
            if (this.wrongAnswer === this.correctAnswer) this.wrongAnswer = this.formatFraction(mult + 1, den);
        }
      }

      init(){
        this.walls=[]
        this.width = Math.min(window.innerWidth, 700)
        this.generateMathProblem(); 
        
        let initialWallWidth = this.width < 400 ? 120 : 150;

        for(var i=0;i<wh/150;i++){
          this.walls.push(new Wall({
            p: new Vec2(Math.random()*(this.width - initialWallWidth) + initialWallWidth/2, i*150+100),
            width: initialWallWidth,
            type: "normal" 
          })) 
        }
        this.player = new Player({ p: new Vec2(this.width/2, 200) })    
      }
      
      start(){
        document.getElementById('musicBg').play().catch(e=>{});
        document.getElementById('startBtn').style.display = 'none';
        document.getElementById('leaderboard').style.display = 'none';
        this.init()
        this.playing=true
        this.time=0
      }
      
      restartGame() {
        document.getElementById('leaderboard').style.display = 'none';
        this.start();
      }

      end(){
        document.getElementById('startBtn').style.display = 'none'; 
        playSound('dead');  
        this.playing=false
        checkNewRecord(parseInt(this.time/100));
      }
      
      update(){
        this.time++
        this.player.update()
        if (this.keystatus.left) this.player.p.x-=8;
        if (this.keystatus.right) this.player.p.x+=8;
        
        if (time%20==0){
          let newType = this.walltypes[parseInt(Math.random()*this.walltypes.length)];
          let wWidth = this.width < 400 ? 120 : 150;
          let safeX = Math.random() * (this.width - wWidth) + wWidth/2;

          let newWall = new Wall({
            p: new Vec2(safeX, this.height),
            width: wWidth,
            type: newType
          });
          
          if (newType === "normal" || newType === "jump") {
            const roll = Math.random();
            if (roll < 0.4) newWall.label = this.correctAnswer;
            else if (roll < 0.8) newWall.label = this.wrongAnswer;
          }
          this.walls.push(newWall);
        }
        
        let touching = false
        this.walls.forEach(wall=>{  
          wall.update() 
          if (wall.p.x-wall.width/2<this.player.p.x+this.player.width/2 && 
              wall.p.x+wall.width/2>this.player.p.x-this.player.width/2){
            if (this.player.p.y>wall.p.y && this.player.p.y<wall.p.y+wall.height+10){ 
              touching=true
              wall.step(this.player)
              this.player.lastBlock=wall
            }
          }
        }) 
        
        if (!touching){
          this.player.lastBlock=null
          document.getElementById("transmiting").pause()
        }
        this.walls = this.walls.filter(wall=>wall.active)
        
        if (this.player.p.y-this.player.height<0){
          if (this.hurt==0){   
            this.hurt=1
            this.player.bloodDelta(-2)
            this.player.v.y=2
            this.player.p.y=10
            TweenMax.to(this,0.5,{hurt: 0})
          }
        }
        
        if (this.player.p.x-this.player.width/2<0) this.player.p.x=this.player.width/2;
        if (this.player.p.x+this.player.width/2>this.width) this.player.p.x=this.width-this.player.width/2;
        if (this.player.p.y>wh+this.player.height) game.end();
      }
      
      draw(){
        ctx.save()
          ctx.translate(ww/2-this.width/2,0)
          // Background Lines
          let span = this.width/60
          ctx.beginPath()
          for(var i=0;i<=this.width/span;i++){ ctx.lineTo(i*span,(i%2)*30) }  
          ctx.fillStyle="white"; ctx.fill();
        
          // Walls and Player
          ctx.beginPath()
          ctx.moveTo(0,0); ctx.lineTo(0,wh);
          ctx.moveTo(this.width,0); ctx.lineTo(this.width,wh);
          ctx.strokeStyle="rgba(255,255,255,0.3)"; ctx.stroke();
        
          this.player.draw()
          this.walls.forEach(wall=>wall.draw())
        ctx.restore()
        
        // Red Flash
        if(this.hurt > 0) {
            ctx.fillStyle="rgba(255,0,0,"+this.hurt+")"
            ctx.fillRect(0,0,ww,wh)
        }
        
        this.player.drawBlood()
        
        // UI
        ctx.textAlign = "center"; 
        ctx.fillStyle='white';
        let fontSize = Math.min(ww / 14, 30); 
        let uiCenterX = ww / 2;
        
        ctx.font = fontSize + "px Arial";
        ctx.fillText("BasementÔºö" + (parseInt(this.time/100)) + "/F", uiCenterX, 80);
        
        // Render the formal question
        drawEquation(ctx, this.questionParts, uiCenterX, 130, fontSize * 1.2, '#ffdd38');
        
        ctx.textAlign = "start"; 
      }
    }

    //------------------------
    // PLAYER CLASS
    //------------------------
    class Player{
      constructor(args){
        let def = {
          p: new Vec2(0,0), v: new Vec2(0,0), a: new Vec2(0,1), 
          width: 40, height: 55, blood: 10, maxBlood: 10, lastBlock: null
        }
        Object.assign(def,args); Object.assign(this,def);
      }
      update(){
        this.p=this.p.add(this.v); this.v=this.v.add(this.a);
      }
      draw(){
        ctx.save()
          ctx.translate(this.p.x,this.p.y)
          ctx.fillStyle="#0047ba"
          ctx.fillRect(-this.width/2,-this.height,this.width,this.height)
          ctx.fillStyle="#ffdd38"
          ctx.fillRect(-5,-30,10,10)
          // Eyes
          ctx.beginPath(); ctx.arc(-6,-40,5,0,Math.PI*2); ctx.arc(+6,-40,5,0,Math.PI*2);
          ctx.fillStyle="white"; ctx.fill();
          ctx.beginPath(); ctx.arc(-6,-40,3,0,Math.PI*2); ctx.arc(+6,-40,3,0,Math.PI*2);
          ctx.fillStyle="black"; ctx.fill();
          // Legs animation
          ctx.save(); ctx.translate(+this.width/2,-40); ctx.rotate(-Math.log(Math.abs(this.v.y/2)+1));
          ctx.fillStyle="#416ee0"; ctx.fillRect(0,0,8,this.height/2); ctx.restore();
          ctx.save(); ctx.translate(-this.width/2,-40); ctx.rotate(Math.log(Math.abs(this.v.y/2)+1));
          ctx.fillStyle="#416ee0"; ctx.fillRect(-8,0,8,this.height/2); ctx.restore();
        ctx.restore()
      }
      drawBlood(){
        let barWidth = 10; let gap = 4;
        let totalWidth = 10 * barWidth + 9 * gap;
        let startX = (ww - totalWidth) / 2;
        for(var i=0;i<10;i++){
          ctx.fillStyle=i<this.blood?"red":"rgba(255,255,255,0.2)"
          ctx.fillRect(startX + i*(barWidth+gap), 40, barWidth, 20)
        }
      }
      bloodDelta(delta){
        if (delta<0) playSound('hurt');
        this.blood+=delta;
        if (this.blood>this.maxBlood) this.blood=this.maxBlood;
        if (this.blood<=0){ this.blood=0; game.end(); }
      }
    }

    //------------------------
    // WALL CLASS
    //------------------------
    class Wall{
      constructor(args){
        let def = {
          p: new Vec2(0,0), v: new Vec2(0,-3), a: new Vec2(0,0),
          width: 150, height: 20, extraHeight: 0, type: "normal", active: true, label: null 
        }
        Object.assign(def,args); Object.assign(this,def);
      }
      update(){
        this.p=this.p.add(this.v); this.v=this.v.add(this.a);
        if (this.p.y<-20) this.active=false;
      }
      draw(){
        ctx.save()
        ctx.translate(this.p.x-this.width/2,this.p.y-this.extraHeight)
          
          // Draw Base Wall
          if (this.type=="normal" || this.type=="hurt"){
            ctx.fillStyle="#888"; ctx.fillRect(0,0,this.width,this.height/2);
          }
          if (this.type=="hurt"){
            ctx.beginPath();
            let span = this.width/16;
            for(var i=0;i<=this.width/span;i+=1){ ctx.lineTo(0+i*span,-(i%2)*15); }
            ctx.fillStyle="#ddd"; ctx.fill();
          }
          if (this.type=="jump"){
            ctx.fillStyle="#53d337"; ctx.fillRect(0,0,this.width,5);
            ctx.fillRect(0,this.height+this.extraHeight,this.width,5);
          }
          if (this.type=="fade"){
            ctx.fillStyle="#ffd428"; ctx.fillRect(0,0,this.width,this.height);
          }
          if (this.type=="slideLeft" || this.type=="slideRight"){
            for(var i=-1;i<this.width/20;i+=1){ 
              let x = 0+i*20+(time%20)* (this.type=="slideLeft"?-1:1);
              let w = 10; if(x<0) x=0; if(x+w>this.width) w = Math.max(0, this.width-x);
              ctx.fillStyle="red";
              ctx.save(); ctx.transform(1, 0,0.5, 1, 0, 0); ctx.fillRect(x ,0,w,this.height); ctx.restore();
            }
          }
          
          // Draw Answer Label
          if (this.label !== null) {
              ctx.shadowColor="black"; ctx.shadowBlur=4;
              drawFormalExpression(ctx, this.label, this.width/2, -8, 24, "white", "center");
              ctx.shadowBlur=0;
          }
        ctx.restore()
      } 
      step(player){
        player.v.y=0
        if (player.lastBlock!=this){
          
          // Math Logic Check
          if (this.label !== null) {
              if (this.label === game.correctAnswer) {
                  playSound('correct'); 
                  player.bloodDelta(1);
                  game.generateMathProblem();
              } else {
                  player.bloodDelta(-1);
                  // TRIGGER RED FLASH
                  game.hurt = 1; 
                  TweenMax.to(game, 0.2, {hurt: 0});
              }
              this.label = null; 
          }

          // Sound
          if (this.type=="normal") playSound('step');
          if (this.type=="fade") playSound('fade');
          if (this.type=="hurt") playSound('hurt');
          if (this.type=="jump") playSound('jump');
        }
        
        // Physics
        if (this.type=="normal") player.p.y = this.p.y;
        if (this.type=="hurt"){
          player.p.y = this.p.y;
          if (player.lastBlock!=this){
            player.bloodDelta(-2); 
            game.hurt=1; TweenMax.to(game,0.2,{hurt: 0});
          }
        }
        if (this.type=="jump"){
          player.v.y = -15; this.extraHeight=10; TweenMax.to(this,0.2,{extraHeight: 0});
        } 
        if (this.type=="slideLeft"){ 
          player.p.x-=3; player.p.y = this.p.y; document.getElementById("transmiting").play();
        }
        if (this.type=="slideRight"){
          player.p.x+=3; player.p.y = this.p.y; document.getElementById("transmiting").play();
        }
        if (this.type=="fade") player.p.y-=2;
      }
    }

    function initCanvas(){
      ww = canvas.width = window.innerWidth
      wh = canvas.height = window.innerHeight
      if(game) {
        game.width = Math.min(ww, 700);
        game.height = wh;
      }
    }
    
    var game = new Game
    initCanvas()
    function init(){ game.init() }
    function update(){ time++; if(game.playing) game.update(); }
    function draw(){ ctx.fillStyle=bgColor; ctx.fillRect(0,0,ww,wh); game.draw(); requestAnimationFrame(draw); }
    function loaded(){ initCanvas(); init(); requestAnimationFrame(draw); setInterval(update,1000/updateFPS); }
    
    window.addEventListener("load",loaded)
    window.addEventListener("resize",initCanvas)

    // Keys
    window.addEventListener('keydown',function(evt){
      let key = evt.key.replace("Arrow","").toLowerCase()
      game.keystatus[key]=true
    })
    window.addEventListener('keyup',function(evt){
      let key = evt.key.replace("Arrow","").toLowerCase()
      game.keystatus[key]=false
    })

    // Touch
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const handleTouch = (dir, active) => (e) => {
        e.preventDefault(); 
        game.keystatus[dir] = active;
        e.target.style.backgroundColor = active ? "rgba(255, 255, 255, 0.4)" : "rgba(255, 255, 255, 0.1)";
    };
    leftBtn.addEventListener('touchstart', handleTouch('left', true), {passive: false});
    leftBtn.addEventListener('touchend', handleTouch('left', false), {passive: false});
    rightBtn.addEventListener('touchstart', handleTouch('right', true), {passive: false});
    rightBtn.addEventListener('touchend', handleTouch('right', false), {passive: false});

    // Name Input
    document.getElementById('submitName').addEventListener('click', submitName);
    document.getElementById('nameInput').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') submitName();
    });
  </script>
</body>
</html>
